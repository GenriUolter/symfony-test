Проєкт на Symfony 8 з авторизацією через JWT і Doctrine ORM.

Цей файл описує локальне розгортання, налаштування змінних середовища, підготовку бази даних, накочення міграцій та створення адміністратора через консольну команду.

---

### Зміст

- [Попередні вимоги](#попередні-вимоги)
- [Встановлення залежностей](#встановлення-залежностей)
- [Налаштування оточення (.env.local)](#налаштування-оточення-envlocal)
- [Підготовка бази даних і міграції](#підготовка-бази-даних-і-міграції)
- [Створення адміністратора](#створення-адміністратора)
- [Запуск застосунку локально](#запуск-застосунку-локально)
- [Аутентифікація та JWT](#аутентифікація-та-jwt)
- [API документація (Swagger)](#api-документація-swagger)
- [Корисні посилання в коді](#корисні-посилання-в-коді)
- [Нотатки](#нотатки)

### Попередні вимоги

- PHP >= 8.4
- Composer
- Будь‑яка з підтримуваних СУБД (рекомендовано PostgreSQL або MySQL/MariaDB)

### Встановлення залежностей

1. Клонувати репозиторій та перейти в каталог проєкту
2. Встановити залежності Composer:

```
composer install
```

### Налаштування оточення (.env.local)

У корені проєкту створіть файл `.env.local`.

Приклад вмісту `.env.local`:

```
# Режим оточення
APP_ENV=dev

# Secret для Symfony (згенеруйте випадкове значення)
APP_SECRET=your_app_secret_here

# Рівень логування
LOG_LEVEL=info

# Налаштування бази даних (ОБЕРІТЬ одну з опцій і розкоментуйте)
# PostgreSQL
DATABASE_URL="postgresql://app:password@127.0.0.1:5432/app_db?serverVersion=16&charset=utf8"

# MySQL / MariaDB
# DATABASE_URL="mysql://app:password@127.0.0.1:3306/app_db?serverVersion=8.0.32&charset=utf8mb4"
# DATABASE_URL="mysql://app:password@127.0.0.1:3306/app_db?serverVersion=10.11.2-MariaDB&charset=utf8mb4"

# SQLite (для швидкого старту)
# DATABASE_URL="sqlite:///%kernel.project_dir%/var/data_%kernel.environment%.db"

# JWT налаштування
JWT_SECRET=your_jwt_secret_here
JWT_TTL=3600
```

Підказки щодо генерації секретів:

- Згенерувати `APP_SECRET`:

```
php -r 'echo bin2hex(random_bytes(16));'
```

- Згенерувати `JWT_SECRET` (можна використати те саме або окреме значення):

```
php -r 'echo bin2hex(random_bytes(32));'
```

### Підготовка бази даних і міграції

Опція 1 — міграції (стандартний варіант):

1. Створити базу даних (якщо вона ще не існує):

```
bin/console doctrine:database:create
```

2. Накатити міграції:

```
bin/console doctrine:migrations:migrate
```

Файл конфігурації міграцій: `config/packages/doctrine_migrations.yaml` (шлях до міграцій: `migrations/`). Параметри підключення до БД беруться з `DATABASE_URL` у `.env.local`.

Опція 2 — використання дампа бази даних (`dump.sql`):

У кореневому каталозі проєкту є файл `dump.sql`. Ви можете відновити стан бази даних із цього файлу як альтернативу міграціям. Переконайтеся, що `DATABASE_URL` у `.env.local` вказує на потрібну порожню базу даних (створіть її за потреби), після чого імпортуйте дамп однією з наведених команд:

- PostgreSQL (psql):

```
psql postgresql://app:password@127.0.0.1:5432/app_db -f dump.sql
```

- MySQL/MariaDB (mysql):

```
mysql -u app -p -h 127.0.0.1 -P 3306 app_db < dump.sql
```

### Створення адміністратора

У проєкті є консольна команда для створення адміністратора:

```
bin/console app:create-admin
```

Під час виконання команда запитає:
- Логін адміністратора: 3–8 символів
- Пароль адміністратора: 6–8 символів

Користувачу буде призначено роль з найвищими правами (`Root`). У разі помилок валідації команда виведе підказки щодо виправлення введених даних.

### Запуск застосунку локально

Варіант 1 (Symfony CLI):

```
symfony server:start -d
```

Варіант 2 (PHP built-in сервер):

```
php -S localhost:8000 -t public
```

Базова адреса: `http://localhost:8000`

### API документація (Swagger)

Документація до REST API доступна за посиланням:

- Локально: `http://localhost:8000/api/doc`
- Відносний шлях у застосунку: `/api/doc`

### Аутентифікація та JWT

- Точка входу для логіну: `POST /api/auth/login`
- Тіло запиту (JSON):

```
{
  "login": "your_login",
  "password": "your_password"
}
```

У відповідь сервіс повертає JSON із полями на кшталт:

```
{
  "success": true,
  "content": {
    "token": "<JWT>",
    "exp": 1735678901
  }
}
```

Для доступу до захищених ендпоінтів під префіксом `/api` необхідно передавати заголовок авторизації у форматі:

```
Authorization: Bearer <JWT>
```

`JWT_SECRET` і `JWT_TTL` зчитуються із середовища (див. `config/services.yaml`, `src/Security/JwtTokenService.php`). Без валідного токена доступ до більшості маршрутів під `/api` буде заборонений (див. `config/packages/security.yaml`).

Швидкий приклад через curl:

```
# 1) Логін: отримати токен
curl -s -X POST http://localhost:8000/api/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"login":"admin","password":"secret"}'

# 2) Виклик захищеного ендпоінта з токеном
curl -H 'Authorization: Bearer <JWT>' http://localhost:8000/api/secure/example
```

- Якщо отримуєте 401/403 при зверненні до `/api`, перевірте правильність `Authorization: Bearer <JWT>` та коректність `JWT_SECRET`/`JWT_TTL`.

### Корисні посилання в коді

- Конфіг безпеки: `config/packages/security.yaml`
- JWT сервіс: `src/Security/JwtTokenService.php`
- Аутентифікатор JWT: `src/Security/JwtAuthenticator.php`
- Контролер авторизації: `src/Controller/AuthController.php`
- Команда створення адміністратора: `src/Command/CreateAdminCommand.php`
- Налаштування Doctrine: `config/packages/doctrine.yaml`
- Міграції Doctrine: `config/packages/doctrine_migrations.yaml`, каталог `migrations/`

### Нотатки

### Ролі та права

- Роль `root`:
    - має повний доступ до ресурсу користувачів (`GET/POST/PUT/DELETE` на будь-який запис).

- Роль `user`:
    - може виконувати `GET` та `PUT` **лише щодо власного запису користувача** (ідентифікація за id з JWT токена);
    - не може виконувати `DELETE`;
    - створення нових користувачів (`POST`) залишено за роллю `root`, оскільки
      в тестовому завданні формально не деталізовано сценарій, у якому звичайний користувач
      створює інших користувачів. Для спрощення та підвищення безпеки створення
      облікових записів централізовано виконує `root`.

### Унікальні обмеження

У реальному застосунку логін та номер телефону потрібно зберігати унікальними,
тому додано унікальні індекси для полів `login` та `phone`.

Окрім цього, для відповідності вимозі тестового завдання про використання
"унікального складового індексу" додано комбінований індекс `login + phone`.
Фактично він дублює унікальність `login`, але залишений для демонстрації
правильної технічної реалізації composite index у схемі БД.

### Відступ від ТЗ: унікальний індекс

У тестовому завданні було вказано вимогу:
> "повісити унікальний складовий індекс на атрибути `login` та `password`".

У реальному застосунку паролі ніколи не зберігаються у відкритому вигляді і не повинні бути частиною ключів/індексів.
Тому в даній реалізації:

- пароль зберігається тільки у вигляді хешу (bcrypt);
- замість індексу по `login + password` використано більш практичний та безпечний варіант — унікальний складовий індекс по `login + phone`.

Це дозволяє:
- не прив’язувати унікальність до секретного значення (пароля),
- зберегти кращі практики безпеки,
- при цьому забезпечити, що один і той самий логін не може бути використаний з тим самим номером телефону.
